#!/usr/bin/env python3
"""
UE별 대역폭(Bandwidth) 정보 추출 스크립트
로그 파일에서 각 UE의 PRB 할당 정보를 기반으로 대역폭을 계산합니다.
"""

import re
import sys
from collections import defaultdict
from typing import Dict, List, Optional, Tuple
from datetime import datetime, timedelta

# PRB당 대역폭 계산 (kHz 단위)
# PRB당 대역폭 = 12 subcarriers × SCS (kHz)
# 예: SCS 15kHz → 12 × 15 = 180 kHz = 0.18 MHz
# 예: SCS 30kHz → 12 × 30 = 360 kHz = 0.36 MHz

def parse_scs_from_log(log_file: str) -> Optional[int]:
    """
    로그 파일에서 Subcarrier Spacing (SCS) 정보를 추출합니다.
    
    Args:
        log_file: 로그 파일 경로
        
    Returns:
        SCS 값 (kHz), 없으면 None
    """
    scs_pattern = re.compile(r'common_scs:\s*(\d+)')
    
    try:
        with open(log_file, 'r', encoding='utf-8') as f:
            for line in f:
                match = scs_pattern.search(line)
                if match:
                    return int(match.group(1))
    except Exception as e:
        print(f"Warning: SCS 파싱 중 오류: {e}")
    
    return None

def get_rnti_to_ue_mapping() -> Dict[str, int]:
    """
    고정된 RNTI → UE 인덱스 매핑을 반환합니다.
    
    Returns:
        {rnti: ue_index} 딕셔너리
    """
    # 고정 매핑: UE0 → 0x4601, UE1 → 0x4602, UE2 → 0x4603
    return {
        '0x4601': 0,
        '0x4602': 1,
        '0x4603': 2
    }

def parse_prb_bandwidth_log(log_file: str, scs_khz: Optional[int] = None) -> Dict[str, Dict[str, List[Dict]]]:
    """
    로그 파일에서 UE별 PRB 할당 정보를 파싱하고 대역폭을 계산합니다.
    
    Args:
        log_file: 로그 파일 경로
        scs_khz: Subcarrier Spacing (kHz). None이면 로그에서 추출 시도
        
    Returns:
        {'pdsch': {rnti: [entries]}, 'pusch': {rnti: [entries]}}
        각 entry는 timestamp, prb_count, bandwidth_mhz 등을 포함
    """
    result = {
        'pdsch': defaultdict(list),
        'pusch': defaultdict(list)
    }
    
    # SCS가 없으면 로그에서 추출
    if scs_khz is None:
        scs_khz = parse_scs_from_log(log_file)
        if scs_khz is None:
            print("Warning: SCS를 찾을 수 없습니다. 기본값 15kHz를 사용합니다.")
            scs_khz = 15
    
    # PRB당 대역폭 계산 (MHz)
    prb_bandwidth_mhz = (12 * scs_khz) / 1000.0  # 12 subcarriers × SCS (kHz) / 1000 = MHz
    
    print(f"SCS: {scs_khz} kHz")
    print(f"PRB당 대역폭: {prb_bandwidth_mhz:.3f} MHz")
    print()
    
    # PDSCH 패턴: PDSCH: rnti=0x4601 h_id=0 k1=4 prb=[0, 42) symb=[1, 14) mod=QPSK rv=0 tbs=309
    pdsch_pattern = re.compile(
        r'^(\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d+).*?'
        r'PDSCH:\s+rnti=(0x[0-9a-fA-F]+)\s+'
        r'(?:h_id=(\d+)\s+)?'
        r'(?:k1=(\d+)\s+)?'
        r'prb=\[(\d+),\s*(\d+)\)'
    )
    
    # PUSCH 패턴: PUSCH: rnti=0x4601 h_id=0 prb=[8, 11) symb=[0, 14) mod=QPSK rv=0 tbs=11
    pusch_pattern = re.compile(
        r'^(\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d+).*?'
        r'PUSCH:\s+rnti=(0x[0-9a-fA-F]+)\s+'
        r'(?:h_id=(\d+)\s+)?'
        r'prb=\[(\d+),\s*(\d+)\)'
    )
    
    try:
        with open(log_file, 'r', encoding='utf-8') as f:
            for line_num, line in enumerate(f, 1):
                # PDSCH 파싱
                match = pdsch_pattern.search(line)
                if match:
                    timestamp_str = match.group(1)
                    rnti = match.group(2).lower()
                    prb_start = int(match.group(5))
                    prb_end = int(match.group(6))
                    
                    prb_count = prb_end - prb_start
                    bandwidth_mhz = prb_count * prb_bandwidth_mhz
                    
                    try:
                        timestamp = datetime.fromisoformat(timestamp_str)
                    except ValueError:
                        timestamp = None
                    
                    entry = {
                        'line': line_num,
                        'timestamp': timestamp,
                        'timestamp_str': timestamp_str,
                        'rnti': rnti,
                        'prb_start': prb_start,
                        'prb_end': prb_end,
                        'prb_count': prb_count,
                        'bandwidth_mhz': bandwidth_mhz,
                        'bandwidth_khz': bandwidth_mhz * 1000.0,
                        'raw_line': line.strip()
                    }
                    result['pdsch'][rnti].append(entry)
                    continue
                
                # PUSCH 파싱
                match = pusch_pattern.search(line)
                if match:
                    timestamp_str = match.group(1)
                    rnti = match.group(2).lower()
                    prb_start = int(match.group(4))
                    prb_end = int(match.group(5))
                    
                    prb_count = prb_end - prb_start
                    bandwidth_mhz = prb_count * prb_bandwidth_mhz
                    
                    try:
                        timestamp = datetime.fromisoformat(timestamp_str)
                    except ValueError:
                        timestamp = None
                    
                    entry = {
                        'line': line_num,
                        'timestamp': timestamp,
                        'timestamp_str': timestamp_str,
                        'rnti': rnti,
                        'prb_start': prb_start,
                        'prb_end': prb_end,
                        'prb_count': prb_count,
                        'bandwidth_mhz': bandwidth_mhz,
                        'bandwidth_khz': bandwidth_mhz * 1000.0,
                        'raw_line': line.strip()
                    }
                    result['pusch'][rnti].append(entry)
    except FileNotFoundError:
        print(f"Error: 파일 '{log_file}'을 찾을 수 없습니다.")
        sys.exit(1)
    except Exception as e:
        print(f"Error: 파일 읽기 중 오류 발생: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)
    
    # 각 채널 타입별로 타임스탬프 기준으로 정렬
    for channel_type in result:
        for rnti in result[channel_type]:
            result[channel_type][rnti] = sorted(
                result[channel_type][rnti],
                key=lambda x: x['timestamp'] if x['timestamp'] is not None else datetime.max
            )
    
    return result

def calculate_bandwidth_per_second(bandwidth_data: Dict[str, Dict[str, List[Dict]]], 
                                    rnti_ue_map: Dict[str, int],
                                    time_window_sec: float = 1.0) -> Dict[int, List[Dict]]:
    """
    1초 윈도우별로 초당 평균 대역폭을 계산합니다 (throughput 방식과 유사).
    
    Args:
        bandwidth_data: parse_prb_bandwidth_log()의 결과
        rnti_ue_map: RNTI → UE 인덱스 매핑
        time_window_sec: 집계 시간 윈도우 (초, 기본값 1.0)
        
    Returns:
        {ue_index: [{'timestamp': ..., 'dl_bandwidth_mhz': ..., 'ul_bandwidth_mhz': ..., ...}]} 딕셔너리
    """
    ue_bandwidth_per_sec = defaultdict(list)
    
    # 모든 RNTI의 엔트리를 UE 인덱스별로 그룹화
    ue_entries = defaultdict(lambda: {'dl': [], 'ul': []})
    
    for rnti, entries in bandwidth_data['pdsch'].items():
        ue_idx = rnti_ue_map.get(rnti, None)
        if ue_idx is not None and 0 <= ue_idx <= 10:
            ue_entries[ue_idx]['dl'].extend(entries)
    
    for rnti, entries in bandwidth_data['pusch'].items():
        ue_idx = rnti_ue_map.get(rnti, None)
        if ue_idx is not None and 0 <= ue_idx <= 10:
            ue_entries[ue_idx]['ul'].extend(entries)
    
    # 각 UE별로 1초 윈도우별 집계
    for ue_idx, entries in ue_entries.items():
        # DL과 UL을 타임스탬프 기준으로 정렬
        all_dl = sorted([e for e in entries['dl'] if e['timestamp'] is not None],
                       key=lambda x: x['timestamp'])
        all_ul = sorted([e for e in entries['ul'] if e['timestamp'] is not None],
                       key=lambda x: x['timestamp'])
        
        # DL 처리: 1초 윈도우별로 집계
        processed_dl_windows = set()
        
        for i, entry in enumerate(all_dl):
            window_start = entry['timestamp']
            window_start_sec = window_start.replace(microsecond=0)
            window_key = window_start_sec
            
            if window_key in processed_dl_windows:
                continue
            
            window_end = window_start_sec + timedelta(seconds=1)
            processed_dl_windows.add(window_key)
            
            # 윈도우 내의 모든 PRB 할당을 합산
            window_entries = [e for e in all_dl[i:]
                            if window_start_sec <= e['timestamp'] < window_end]
            
            if window_entries:
                # 초당 평균 대역폭 = 윈도우 내 평균 대역폭
                avg_bandwidth_mhz = sum(e['bandwidth_mhz'] for e in window_entries) / len(window_entries)
                avg_prb_count = sum(e['prb_count'] for e in window_entries) / len(window_entries)
                
                # 해당 윈도우의 엔트리 찾기 또는 생성
                bw_entry = None
                for existing in ue_bandwidth_per_sec[ue_idx]:
                    if existing['timestamp'] == window_start_sec:
                        bw_entry = existing
                        break
                
                if bw_entry is None:
                    bw_entry = {
                        'timestamp': window_start_sec,
                        'dl_bandwidth_mhz': 0.0,
                        'ul_bandwidth_mhz': 0.0,
                        'dl_avg_prb': 0.0,
                        'ul_avg_prb': 0.0,
                        'dl_count': 0,
                        'ul_count': 0
                    }
                    ue_bandwidth_per_sec[ue_idx].append(bw_entry)
                
                bw_entry['dl_bandwidth_mhz'] = avg_bandwidth_mhz
                bw_entry['dl_avg_prb'] = avg_prb_count
                bw_entry['dl_count'] = len(window_entries)
        
        # UL 처리: 1초 윈도우별로 집계
        processed_ul_windows = set()
        
        for i, entry in enumerate(all_ul):
            window_start = entry['timestamp']
            window_start_sec = window_start.replace(microsecond=0)
            window_key = window_start_sec
            
            if window_key in processed_ul_windows:
                continue
            
            window_end = window_start_sec + timedelta(seconds=1)
            processed_ul_windows.add(window_key)
            
            # 윈도우 내의 모든 PRB 할당을 합산
            window_entries = [e for e in all_ul[i:]
                            if window_start_sec <= e['timestamp'] < window_end]
            
            if window_entries:
                # 초당 평균 대역폭 = 윈도우 내 평균 대역폭
                avg_bandwidth_mhz = sum(e['bandwidth_mhz'] for e in window_entries) / len(window_entries)
                avg_prb_count = sum(e['prb_count'] for e in window_entries) / len(window_entries)
                
                # 해당 윈도우의 엔트리 찾기 또는 생성
                bw_entry = None
                for existing in ue_bandwidth_per_sec[ue_idx]:
                    if existing['timestamp'] == window_start_sec:
                        bw_entry = existing
                        break
                
                if bw_entry is None:
                    bw_entry = {
                        'timestamp': window_start_sec,
                        'dl_bandwidth_mhz': 0.0,
                        'ul_bandwidth_mhz': 0.0,
                        'dl_avg_prb': 0.0,
                        'ul_avg_prb': 0.0,
                        'dl_count': 0,
                        'ul_count': 0
                    }
                    ue_bandwidth_per_sec[ue_idx].append(bw_entry)
                
                bw_entry['ul_bandwidth_mhz'] = avg_bandwidth_mhz
                bw_entry['ul_avg_prb'] = avg_prb_count
                bw_entry['ul_count'] = len(window_entries)
        
        # 타임스탬프 기준으로 정렬
        ue_bandwidth_per_sec[ue_idx].sort(key=lambda x: x['timestamp'])
    
    return ue_bandwidth_per_sec

def print_bandwidth_summary(bandwidth_per_sec: Dict[int, List[Dict]]):
    """UE별 초당 대역폭 요약 정보를 출력합니다."""
    print("=" * 100)
    print("UE별 초당 대역폭(Bandwidth per Second) 정보 요약")
    print("=" * 100)
    
    for ue_idx in sorted(bandwidth_per_sec.keys()):
        entries = bandwidth_per_sec[ue_idx]
        if not entries:
            continue
        
        print(f"\n[UE{ue_idx}] 총 {len(entries)}개의 1초 윈도우")
        print("-" * 100)
        
        # DL 통계
        dl_bandwidths = [e['dl_bandwidth_mhz'] for e in entries if e['dl_bandwidth_mhz'] > 0]
        dl_prbs = [e['dl_avg_prb'] for e in entries if e['dl_avg_prb'] > 0]
        
        if dl_bandwidths:
            print(f"  DL (Downlink) 초당 대역폭:")
            print(f"    - 최소값: {min(dl_bandwidths):.3f} MHz ({min(dl_prbs):.2f} PRB)")
            print(f"    - 최대값: {max(dl_bandwidths):.3f} MHz ({max(dl_prbs):.2f} PRB)")
            print(f"    - 평균값: {sum(dl_bandwidths) / len(dl_bandwidths):.3f} MHz ({sum(dl_prbs) / len(dl_prbs):.2f} PRB)")
            print(f"    - 데이터가 있는 윈도우 수: {len(dl_bandwidths)}")
        else:
            print(f"  DL (Downlink): 데이터 없음")
        
        # UL 통계
        ul_bandwidths = [e['ul_bandwidth_mhz'] for e in entries if e['ul_bandwidth_mhz'] > 0]
        ul_prbs = [e['ul_avg_prb'] for e in entries if e['ul_avg_prb'] > 0]
        
        if ul_bandwidths:
            print(f"  UL (Uplink) 초당 대역폭:")
            print(f"    - 최소값: {min(ul_bandwidths):.3f} MHz ({min(ul_prbs):.2f} PRB)")
            print(f"    - 최대값: {max(ul_bandwidths):.3f} MHz ({max(ul_prbs):.2f} PRB)")
            print(f"    - 평균값: {sum(ul_bandwidths) / len(ul_bandwidths):.3f} MHz ({sum(ul_prbs) / len(ul_prbs):.2f} PRB)")
            print(f"    - 데이터가 있는 윈도우 수: {len(ul_bandwidths)}")
        else:
            print(f"  UL (Uplink): 데이터 없음")

def print_bandwidth_detailed_per_sec(bandwidth_per_sec: Dict[int, List[Dict]], 
                                     ue_idx: Optional[int] = None):
    """특정 UE의 상세 초당 대역폭 정보를 출력합니다 (extract_ue_priority.py 스타일)."""
    if ue_idx is not None:
        ues_to_print = [ue_idx] if ue_idx in bandwidth_per_sec else []
    else:
        ues_to_print = sorted(bandwidth_per_sec.keys())
    
    for ue_idx_print in ues_to_print:
        entries = bandwidth_per_sec[ue_idx_print]
        if not entries:
            continue
        
        # 기준 시간 찾기 (첫 번째 유효한 타임스탬프)
        first_timestamp = None
        for entry in entries:
            if entry.get('timestamp') is not None:
                first_timestamp = entry['timestamp']
                break
        
        if first_timestamp is None:
            print(f"\n[경고] UE{ue_idx_print}: 유효한 타임스탬프가 없습니다.")
            continue
        
        print(f"\n{'=' * 80}")
        print(f"UE{ue_idx_print} 상세 정보 (전체 {len(entries)}개, 시간 순서대로 정렬)")
        print(f"UE별 기준 시간: {first_timestamp.isoformat()}")
        print(f"{'=' * 80}")
        print(f"{'시간(분:초)':<15} {'DL 대역폭(MHz)':<18} {'DL PRB':<12} {'UL 대역폭(MHz)':<18} {'UL PRB':<12}")
        print("-" * 80)
        
        for entry in entries:
            if entry['timestamp'] is not None:
                # 분:초.XX 형식으로 표시 (시간 제외, 소수점 둘째 자리)
                minutes = entry['timestamp'].minute
                seconds = entry['timestamp'].second + entry['timestamp'].microsecond / 1000000.0
                time_str = f"{minutes:02d}:{seconds:05.2f}"
            else:
                time_str = "N/A"
            
            dl_bw = entry['dl_bandwidth_mhz'] if entry['dl_bandwidth_mhz'] > 0 else 0.0
            dl_prb = entry['dl_avg_prb'] if entry['dl_avg_prb'] > 0 else 0.0
            ul_bw = entry['ul_bandwidth_mhz'] if entry['ul_bandwidth_mhz'] > 0 else 0.0
            ul_prb = entry['ul_avg_prb'] if entry['ul_avg_prb'] > 0 else 0.0
            
            print(f"{time_str:<15} {dl_bw:<18.3f} {dl_prb:<12.2f} {ul_bw:<18.3f} {ul_prb:<12.2f}")

def main():
    # 기본 로그 파일 경로
    default_log_file = "gnb.log"
    
    log_file = default_log_file
    ue_idx = None
    channel_type = None
    scs_khz = None
    
    # 명령줄 인자 파싱
    i = 1
    while i < len(sys.argv):
        if sys.argv[i] == '--ue' and i + 1 < len(sys.argv):
            ue_idx = int(sys.argv[i + 1])
            i += 2
        elif sys.argv[i] == '--channel' and i + 1 < len(sys.argv):
            channel_type = sys.argv[i + 1]
            i += 2
        elif sys.argv[i] == '--scs' and i + 1 < len(sys.argv):
            scs_khz = int(sys.argv[i + 1])
            i += 2
        elif sys.argv[i].startswith('--'):
            # 알 수 없는 옵션은 건너뛰기
            i += 1
        else:
            # 로그 파일 경로로 간주
            log_file = sys.argv[i]
            i += 1
    
    # 로그 파일이 지정되지 않았으면 기본값 사용
    if log_file == default_log_file and len(sys.argv) == 1:
        print(f"로그 파일이 지정되지 않았습니다. 기본값 '{default_log_file}'을 사용합니다.")
        print("사용법: python3 extract_ue_bandwidth.py [log_file] [--ue <ue_index>] [--channel <pdsch|pusch>] [--scs <kHz>]")
        print(f"예시: python3 extract_ue_bandwidth.py {default_log_file}")
        print(f"예시: python3 extract_ue_bandwidth.py {default_log_file} --ue 0 --channel pdsch")
        print()
    
    # 데이터 파싱
    print(f"로그 파일 파싱 중: {log_file}")
    bandwidth_data = parse_prb_bandwidth_log(log_file, scs_khz)
    
    # RNTI → UE 매핑 (고정값 사용)
    rnti_ue_map = get_rnti_to_ue_mapping()
    print("RNTI → UE 인덱스 매핑 (고정값):")
    for rnti, ue_idx_mapped in sorted(rnti_ue_map.items()):
        print(f"  RNTI {rnti} → UE{ue_idx_mapped}")
    print()
    
    # 초당 대역폭 계산
    print("초당 대역폭 계산 중...")
    bandwidth_per_sec = calculate_bandwidth_per_second(bandwidth_data, rnti_ue_map)
    print()
    
    # 요약 출력
    print_bandwidth_summary(bandwidth_per_sec)
    
    # 상세 출력 (항상 출력)
    print("\n" + "=" * 100)
    print("상세 정보 (초당 대역폭)")
    print("=" * 100)
    print_bandwidth_detailed_per_sec(bandwidth_per_sec, ue_idx)

if __name__ == '__main__':
    main()
